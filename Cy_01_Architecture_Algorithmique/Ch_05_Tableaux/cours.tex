
\section{Tableaux et type \texttt{list} en \python}

\subsection{Deux structures de données en informatique.}

Les données manipulées en informatique sont organisées, que ce soit dans la mémoire où dans la manière d'y accéder, de les manipuler. 
Une telle organisation porte le nom de \textbf{structure de données}, en voici deux grandes.  

\begin{description}
  \item[Tableau] Les données sont stockées dans des cases contigües de la mémoire de l'ordinateur, chaque emplacement étant souvent indicé par un entier. 
    A priori, il n'est pas possible d'en rajouter autant que possible : cette place a été préallouée. 
    Pour accéder au contenu de l'emplacement numéro $k$, la machine a seulement besoin de connaître 
l'adresse de la première case mémoire et de la largeur de chaque case (faire un dessin). 
    L'accès en lecture et en écriture à une donnée (à partir du numéro de son emplacement) se fait donc en temps constant (on dit $O(1)$).
    L'ajout d'une nouvelle donnée à un tableau peut alors être problématique !
  \item[Liste (chaînée)] Les données ne sont pas stockées de manière organisée dans la mémoire, 
mais de chaque emplacement on pointe l'emplacement suivant. 
    Ainsi, l'accès (en lecture ou en écriture) ne se fait plus en temps constant, mais l'ajout d'une nouvelle donnée se fait simplement en temps constant. 
\end{description}

\subsection{Réalisation en \python}

Les objets de type \pyv{list} en Python sont des tableaux : c'est une 
dénomination fâcheuse car, partout ailleurs en informatique, le terme
\textbf{liste} désigne en fait une liste chaînée. Prenez donc
l'habitude de dire \og tableau\fg, ou \og liste Python \fg\ et non \og liste\fg\ quand vous parlez de cette
structure.

Cependant, il y a une raison à cette dénomination : ces tableaux en Python possèdent presque 
la propriété des listes, dans le sens où l'ajout d'un nouvel élément se fait en temps constant 
\textbf{amorti}. Cela signifie que la plupart de ces ajouts se font en temps constants car en fait 
Python a \og gardé des cellules en réserve\fg, mais parfois l'ajout d'un élément force la création 
d'un nouveau tableau avec plus de cellules de réserve, et la copie de l'ancien tableau dans le 
nouveau. Cette opération est coûteuse, mais elle 
est rare. En moyenne, chaque ajout à un coût constant.

On parle alors de \textbf{tableaux dynamiques}.

\begin{multicols}{2}
Pour créer un tableau on peut le donner en extension.

\begin{pyconsole}
t = [23, 41, 101]
t
\end{pyconsole}

On peut aussi le donner en compréhension.

\begin{pyconsole}
u = [k**2 for k in range(10)]
u
\end{pyconsole}
On peut alors accéder à ses éléments via leur indice.
\begin{pyconsole}
t[0]
u[1]
u[9]
\end{pyconsole}

Attention à utiliser un indice existant !
\begin{pyconsole}
>>> t[3]
\end{pyconsole}
%Traceback (most recent call last):
%  File "<stdin>", line 1, in <module>
%IndexError: list index out of range

Les indices appartiennent à $\ii{0,\texttt{len(t)}}$.
%\clearslide{}
Mais on peut aussi compter les éléments à partir de la fin, en utilisant des indices négatifs !
\begin{pyconsole}
t[-1] # dernier élément
t[-2] # avant-dernier
t[-3]
\end{pyconsole}

Attention, là aussi, à ne pas sortir du tableau !

\begin{pyverbatim}
>>> t[-4]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
\end{pyverbatim}

Enfin, il y a une liste Python particulière : la liste vide~\pyv{[]}.

\end{multicols}


\subsection{Opérations usuelles}

\subsubsection{Concaténation}
Concaténer deux tableaux revient à les mettre bout à bout, on l'effectue en Python avec 
l'opérateur \pyv{+}.
\begin{pyconsole}
t+u
u+t
\end{pyconsole}
Dans cette opération, les deux tableaux sont intégralement recopiés. 

\subsubsection{Quelques calculs}
La longueur se calcule avec la fonction \pyv{len}. Pour des listes Python de nombres, le maximum 
se calcule avec la fonction \pyv{max}, le minimum avec \pyv{min} et la somme des éléments de la 
liste avec \pyv{sum}.
\begin{pyconsole}
len(t)
max(t)
min(t)
sum(t)
\end{pyconsole}

On peut aussi tester l'appartenance d'un élément dans une liste Python avec \pyv{in}.

\begin{pyconsole}
42 in t
[] in [[]]
\end{pyconsole}

Enfin, on peut recopier plusieurs fois un \textbf{même} tableau avec l'opérateur \pyv{*}.

\begin{pyconsole}
4*t
t*4
\end{pyconsole}




\subsubsection{Un peu de méthodes}
Python est un langage \textbf{orienté objet} : en \python, tout est un \textbf{objet}, et ces objets 
sont regroupées en \textbf{classes}. Une \textbf{méthode} est une fonction qui s'applique aux objets 
d'une classe particulière. Si \texttt{method} est une méthode de la classe \texttt{c}, et si 
\texttt{a} est un objet de cette classe, alors on applique \texttt{method} à \texttt{a} avec la 
syntaxe suivante : \texttt{a.method()}, les parenthèses pouvant contenir des paramètres.\\

On peut ajouter un élément à un tableau avec la méthode \texttt{append}. Le point important est que 
cette opération s'effectue en temps constant amorti.
\begin{pyconsole}
t.append(-42)
t
\end{pyconsole}
\`A votre avis, pour un objet \pyv{x}, est-il équivalent d'effectuer \pyv{t+[x]} et \pyv{t.append(x)} ?

On peut aussi enlever le dernier élément d'une liste Python avec la méthode \pyv{pop()}.
\begin{pyconsole}
x = t.pop()
t
x
\end{pyconsole}

Les autres méthodes disponibles sont rassemblées dans le tableau~\ref{tab.list.methodes}. Elles ne sont pas exigibles.
%\begin{figure}[!h]
  \begin{center}
    \begin{tabular}{|c|c|}
      \hline 
      Méthode & Description \\
      \hline
      \texttt{append(x)} & Ajoute \texttt{x} en fin de liste \\
      \hline
      \texttt{extend(L)} & Concatène la liste \texttt{L} en fin de liste \\
      \hline
      \texttt{insert(i,x)} & Insère  \texttt{x} à la position \texttt{i} \\
      \hline
      \texttt{remove(x)} & Supprime la première occurence de \texttt{x} (erreur si impossible)\\
      \hline
      \texttt{pop(i)} & Supprime l'élément en position \texttt{i} (si vide, le dernier) \\
      \hline 
      \texttt{index(x)} & Renvoie l'indice de la première occurence de \texttt{x} (erreur si impossible)\\
      \hline
      \texttt{count(x)} & Renvoie le nombre d'occurences de \texttt{x} \\
      \hline
      \texttt{sort(cmp,key,rev)} & Trie la liste (nombreuses options) \\
      \hline
      \texttt{reverse()} & Renverse la liste \\
      \hline
    \end{tabular}
    \captionof{table}{Méthodes applicables aux listes.}
  \label{tab.list.methodes}
  \end{center}

%
%%%\clearslide{}
\subsection{Tranchage}

On peut directement accéder à une sous-liste Python (ou tranche ---\textbf{slice} en anglais--- 
c'est-à-dire bloc de cases consécutives) d'une liste, c'est ce que l'on appelle le tranchage 
(\textit{slicing}).

On utilise les  syntaxes 
\begin{itemize}
  \item \pyv{u[i:j]} pour accéder à la tranche de la liste \pyv{u} allant des indices \pyv{i} à \pyv{j-1} ;
  \item \pyv{u[i:]} pour accéder à la tranche allant de l'indice \pyv{i} à la fin de la liste \pyv{u} ;
  \item \pyv{u[:j]} pour accéder à la tranche allant du début de la liste \pyv{u} à l'indice \pyv{j-1};
  \item \pyv{u[:]} pour accéder à la tranche complète (toute la liste \pyv{u}) ;
  \item \pyv{u[i:j:p]} pour accéder à la tranche de la liste \pyv{u} allant des indices \pyv{i} à \pyv{j-1}, par pas de \pyv{p}.
\end{itemize}

\begin{pyconsole}
u
u[2:5]
u[2:]
u[:5]
u[1:8:2]
\end{pyconsole}

\subsection{Tableaux multidimensionnels}

On peut représenter une matrice avec des listes Python, par exemple en la décrivant ligne par 
ligne. 
Par exemple, on peut représenter la matrice 
\begin{equation*}
  M=\begin{pmatrix}
    1&2&3 \\ 4&5&6 \\ 7&8&9
  \end{pmatrix}
\end{equation*}
par
\begin{pyconsole}
M = [[1,2,3],[4,5,6],[7,8,9]]
M
M[0][2]
\end{pyconsole}
Cependant, cela ne permet pas d'effectuer les opérations classiques sur les matrices. On préférera 
utiliser les possibilités de la bibliothèque de calcul numérique \pyv{numpy}.

\section{Alias}

Parfois, lorsque l'on manipule des tableaux, on observe un phénomène étrange qui laisse pantois : 
c'est l'\textbf{aliasing}. C'est une notion assez subtile, mais qu'il est bon de connaître pour 
éviter les problèmes qui en découlent, ou au moins avoir une parade lorsqu'on s'y trouve 
confronté.\\


Commençons par un exemple où tout se passe intuitivement :
\begin{pyconsole}
x = 3
y = x
x = 42
\end{pyconsole}

Que vaut alors \pyv{y} ? 
\begin{pyconsole}
y
\end{pyconsole}

Avec des listes Python, cela ne fonctionne pas exactement de cette façon : 
\begin{pyconsole}
x = [0]*5
y = x
x[0] = 42
\end{pyconsole}
Que vaut alors \pyv{y} ? 
\begin{pyconsole}
y
\end{pyconsole}
Tâchons de donner une explication à ce phénomène.
\begin{itemize}
  \item Pour les objets de type \textbf{non mutable} (on ne peut pas les modifier, comme les types 
  \pyv{int}, \pyv{float}, \pyv{bool}, \pyv{str}, \pyv{tuple}), une instruction du type \pyv{x = y} 
crée une nouvelle variable : la variable \pyv{x} pointe vers une case contenant la valeur de 
\pyv{y}, et l'on dit que \pyv{x} et \pyv{y} sont des \textbf{alias} de cette valeur. Réattribuer à 
\pyv{x} ou \pyv{y} une nouvelle valeur casse cet alias : les deux variables ne pointent plus vers la 
même valeur.
  \item Pour les objets de type \textbf{mutable}, les choses sont plus compliquées : on peut modifier 
leur contenu sans les réassigner. C'est le cas des listes \python. Après une instruction du type 
\pyv{x = y} , les variables \pyv{x} et \pyv{y} pointent vers le même objet : ce sont des 
\textbf{alias} de cet objet là aussi. Mais si l'on modifie le contenu de \pyv{x}, sans réaffecter 
\pyv{x}, l'alias n'est pas cassé et l'on modifie à la fois \pyv{x} et \pyv{y}.
\end{itemize}



La fonction \pyv{id()}, qui affiche pour chaque objet son \og numéro d'identité\fg, permet de 
mettre cela en évidence :
\begin{multicols}{2}
\begin{pyconsole}
x = 3
y = x
id(x),id(y)
x = 42
id(x),id(y)
\end{pyconsole}

%et

\begin{pyconsole}
x = [0]*5
y = x
id(x),id(y)
x[0] = 42
id(x),id(y)
\end{pyconsole}

\end{multicols}
Si l'on veut que \pyv{x} et \pyv{y} ne soient plus des alias, on pourra plutôt utiliser la méthode 
\pyv{copy()}.

\begin{pyconsole}
x = [0]*5
y = x.copy()
id(x),id(y)
x[0] = 42
y
\end{pyconsole}

Il existe d'autres manières pour des tableaux de casser cet alias : \pyv{y = list(x)}, \pyv{y = 
x[:]} ou encore \pyv{y = x+[]}.

Cependant, en insérant des tableaux dans d'autres tableaux, on a une notion de \og profondeur\fg. Les 
techniques données ci-dessus ne permettent de rompre un alias qu'au niveau de l'enveloppe externe. 
Il existe la fonction \pyv{deepcopy} de la bibliothèque \pyv{copy}, qui effectue une copie totale 
d'un objet, en profondeur comme son nom l'indique. Cela dit il est peu probable que nous en ayons 
besoin.

\section{Algorithmes}

Vous devez être capables de reproduire quelques algorithmes sur les listes Python : ils figurent 
au programme de l'informatique tronc commun.

\subsection{Calcul de la moyenne et de la variance.}
  Pour un tableau de nombres $t = [t_0,\dots,t_{n-1}]$ de longueur $n$, on voudra souvent calculer sa moyenne 
$   \bar{t} = \dfrac{1}{n} \sum_{k=0}^{n-1} t_k   $   ainsi que sa variance $
    \sigma^2(t) = \dfrac{1}{n} \sum_{k=0}^{n-1} \p{t_k - \bar{t}}^2 = \p{\dfrac{1}{n} \sum_{k=0}^{n-1} t_k^2} - \p{\bar{t}}^2$.
    
  On réalise cela de manière naïve. Exécutons donc le script suivant.



\begin{pyverbatim}
def moyenne(t):
    """Calcule la moyenne de t
       Précondition : t est un tableau de nombres non vide"""
    s = 0 
    for x in t:
        # Invariant : s == somme des éléments de t avant x
        s = s + x 
    return s/len(t)
\end{pyverbatim}

\begin{lstlisting}
def variance(t):
    """Renvoie la variance de t
       Précondition : t est un tableau de nombres non vide"""
    sc = 0
    for x in t:
        # Invariant : sc == somme des carrés des éléments de t avant x
        sc = sc + x**2 
    return sc/len(t) - moyenne(t)**2

t = [i for i in range(101)]
print(moyenne(t))
print(variance(t))
\end{lstlisting}


%Cela renvoie alors :
%\begin{quote}
%  \printpythontex[verb]
%\end{quote}


Une solution plus naturelle dans d'autres langages (mais pas \python) pour calculer la moyenne, 
serait de parcourir \pyv{t} suivant ses indices. Par exemple, pour le calcul de la moyenne, cela 
s'écrit comme suit.
\begin{pyverbatim}
def moyenne(t):
    """Calcule la moyenne de t
       Précondition : t est un tableau de nombres non vide"""
    n = len(t) # Longueur de t
    s = 0 
    for i in range(n):
        # Invariant : s == sum(t[0:i])
        s = s + t[i]
    return s/n 
\end{pyverbatim}



\subsection{Recherche du maximum d'un tableau}

\subsubsection{Obtenir la valeur du maximum}

On cherche à obtenir le maximum d'un tableau de nombres. Pour cela, on balaie séquentiellement le tableau en se souvenant du plus grand nombre déjà rencontré. 
\begin{pyverbatim}
def maxi(t):
    """Renvoie le plus grand élément de t.
       Précondition : t est un tableau non vide"""
    m = t[0]
    for x in t:
        # Invariant : m est le plus grand élément trouvé jusqu'ici
        if x > m:
            m = x # On a trouvé plus grand, on met à jour m
    return m

print(maxi([-5,2,9,-6,3]))
\end{pyverbatim}


Cela renvoie alors :
\begin{pyverbatim}
9
\end{pyverbatim}

Dans de nombreux autres langages de programmation, on ne parcourt pas directement les éléments d'un 
tableau mais leurs indices. On écrira
quelque chose ressemblant plutôt à ceci. 
\begin{pyverbatim}
def maxi(t):
    """Renvoie le plus grand élément de t.
       Précondition : t est un tableau non vide"""
    m = t[0] # Initialisation par le premier élément
    for i in range(1, len(t)):
        # Invariant : m == max(t[0:i])
        if t[i] > m:
            m = t[i] # On a trouvé plus grand, on met à jour m
    return m
\end{pyverbatim}
En Python, c'est moins élégant que l'autre solution.



\subsubsection{Obtenir l'indice du maximum}
On veut maintenant écrire une fonction \pyv{indicemaxi} donnant l'indice d'un plus grand élément d'un tableau, passé en argument.


On reprend la même idée que précédemment en parcourant le tableau par ses indices. On garde alors 
en mémoire l'indice du plus grand élément déjà trouvé.

Dans la plupart des langages, on écrira le script suivant.
\begin{lstlisting}
def indicemaxi(t):
    """Renvoie l'indice du plus grand élément de t.
       Précondition : t est un tableau non vide"""
    im = 0 # Indice du maximum, initialisation par le premier élément
    for i in range(1, len(t)):
        # Invariant : im est indice d'un plus grand élément de t[0:i]
        if t[i] > t[im]:
            im = i # On a trouvé plus grand, on met à jour im
    return im
    
print(indicemaxi([5,-1,10,3]))
\end{lstlisting}

Cela renvoie alors \pyv{2}.
%\begin{quote}
%  \printpythontex[verb]
%\end{quote}

Cependant, les vrais pythonistes écriraient plutôt ceci. 
\begin{lstlisting}
def indicemaxi(t):
    """Renvoie l'indice du plus grand élément de t.
       Précondition : t est un tableau non vide"""
    im = 0 # Indice du maximum, initialisation par le premier élément
    for i, x in enumerate(t):
        # Invariant : im est indice d'un plus grand élément de t[0:i]
        if x > t[im]:
            im = i # On a trouvé plus grand, on met à jour im
    return im
\end{lstlisting}



%%%\clearslide{}
\subsection{Recherche séquentielle d'un élément dans un tableau}

On veut écrire une fonction \pyv{appartient(t,e)} retournant un booléen disant si un
élément \pyv{e} appartient au tableau \pyv{t}. 

Pour cela, on parcourt séquentiellement le tableau en s'arrêtant dès qu'on le trouve. Si on a épuisé 
le tableau sans le trouver, on renvoie \pyv{False}. 
On écrit alors le script suivant.
\begin{pyverbatim}
def appartient(e, t):
    """Renvoie un booléen disant si e appartient à t
       Précondition : t est un tableau"""
    for x in t:
        # Invariant : e n'est pas positionné dans t avant x
        if e == x:
            return True # On a trouvé e, on s'arrête
    return False
 
t = [i**3 for i in range(10)]
print(appartient(3,t))
print(appartient(8,t))
\end{pyverbatim}
Cela renvoie alors :
\pyv{False} puis \pyv{True}.

On peut aussi vouloir obtenir l'indice de la première occurrence de cet élément.
On peut alors modifier la fonction précédente pour parcourir le tableau par ses indices, s'arrêter 
dès que l'on trouve l'élément et renvoyer \pyv{None} sinon.
\begin{lstlisting}
def ind_appartient(e,t):
    """Renvoie l'indice de la première occurrence de e dans t,
       None si e n'est pas dans t
       Précondition : t est un tableau"""
    for i in len(t):
        # Invariant : e n'est pas dans t[0:i]
        if t[i] == e:
            return i # On a trouvé e à l'indice i
    return None
\end{lstlisting}


\subsection{Recherche dichotomique dans un tableau trié}

Dans le problème précédent de recherche d'un élément séquentiellement dans un tableau, on risque de parcourir intégralement le tableau si ce l'élément se trouve à la fin du tableau. 
Cependant, si le tableau est trié, on peut éviter ceci. 

On suppose donc que l'on cherche un élément dans un tableau préalablement \textbf{trié par ordre croissant}. On regarde alors l'élément \og au milieu du tableau \fg{}, ce que l'on pourrait appeler un  \textbf{pivot}. 
Si ce pivot est plus petit que ce que l'on cherche, on sait qu'il faut chercher à droite du pivot. 
Si ce pivot est plus grand que ce que l'on cherche, on sait qu'il faut chercher à gauche du pivot. 

Pour faire cela, on va garder en mémoire une tranche de notre tableau, que l'on va affiner par dichotomie. 

\begin{pyverbatim}
def appartient_dicho(e,t):
    """Renvoie un booléen indiquant si e est dans t
       Préconditions : t est un tableau de nombres trié par ordre croissant
                       e est un nombre"""
    g = 0 # Limite gauche de la tranche où l'on recherche e
    d = len(t)-1 # Limite droite de la tranche où l'on recherche e
    while g <= d: # La tranche où l'on cherche e n'est pas vide
        m = (g+d)//2 # Milieu de la tranche où l'on recherche e
        pivot = t[m] 
        if e == pivot: # On a trouvé e
            return True
        elif e < pivot: 
            d = m-1 # On recherche e dans la partie gauche de la tranche
        else:
            g = m+1 # On recherche e dans la partie droite de la tranche
    return False
    
t = [i**2 for i in range(101)]
print(appartient_dicho(11,t))
print(appartient_dicho(81,t))
\end{pyverbatim}
Cela renvoie alors :
\begin{quote}
%\printpythontex[verb]
\pyv{False}
\pyv{True}
\end{quote}


On remarquera que, si la tableau \pyv{t} (trié) est de taille $n$, alors la recherche dichotomique effectuera de l'ordre de $\ln(n)$ opérations (comparaisons de flottants, additions et divisions d'entiers, affectations etc.).
On dira que l'on effectue $O(\ln n)$ opérations.
C'est bien mieux que le pire des cas de la recherche séquentielle, qui nécessite $O(n)$ opérations \og en moyenne \fg{} (si l'élément recherché est répartie aléatoirement et uniformément dans le tableau) ainsi que dans le pire des cas.
%%\section{Exercices}
%
%%%\begin{exo}
%%    Écrire une fonction \pyv{maxi_double(M)} prenant en argument une matrice de nombres \pyv{M} (représentée comme liste de listes) et renvoyant le maximum de \pyv{M}?
%%%\end{exo}
%%
%%
%%%\begin{exo}
%%  \'Ecrire une fonction \pyv{liste_imax(t)} renvoyant la liste des indices où le maximum de \pyv{t} est atteint.
%%%\end{exo}
%
%
%%\begin{exo}
%  \'Ecrire une fonction \pyv{indice(x, t)} renvoyant un indice
%\pyv{i} tel que \pyv{t[i]==x} si \pyv{x} apparaît dans le tableau \pyv{t} et $-1$ sinon.
%%\end{exo}
%
%%\begin{exo}
%  \'Ecrire une fonction \pyv{tous_les_indices(e,t)} renvoyant la liste de tous les indices des occurences de \pyv{e} dans le tableau \pyv{t}.
%%\end{exo}
%
%%\begin{exo}
%  Écrire une fonction \pyv{compte(e,t)} renvoyant le nombre d'occurences de \pyv{e} dans le tableau \pyv{t}.
%%\end{exo}
%
%%\begin{exo}
%  \'Ecrire une fonction \pyv{ind_appartient_dicho(e,t)} renvoyant l'indice d'une occurence de \pyv{e} dans le tableau \pyv{t} (\pyv{None} si \pyv{e} n'est pas dans \pyv{t}), en supposant que \pyv{t} est trié par ordre croissant.
%%\end{exo}
%
%
%%\begin{exo}
%  \'Ecrire une fonction \pyv{dec_appartient_dicho(e,t)} renvoyant un booléen indiquant si \pyv{e} est dans le tableau \pyv{t}, en supposant que \pyv{t} est trié par ordre décroissant.
%%\end{exo}
%
%%\begin{exo}
%  Écrire une fonction \pyv{compte(e,t)} comptant le nombre d'occurences de l'élément \pyv{e} dans le tableau \texttt{t}.
%%\end{exo}

